using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Media.Media3D;
using System.Windows.Threading;
using System.Xml;
using Dynamo.Controls;
using Dynamo.Graph.Nodes;
using Dynamo.Graph.Nodes.CustomNodes;
using Dynamo.Graph.Workspaces;
using Dynamo.Logging;
using Dynamo.Models;
using Dynamo.Selection;
using Dynamo.Utilities;
using Dynamo.Visualization;
using Dynamo.Wpf.Properties;
using Dynamo.Wpf.Rendering;
using DynamoUtilities;
using Newtonsoft.Json;

namespace Dynamo.Wpf.ViewModels.Watch3D
{
    /// <summary>
    /// The HelixWatch3DViewModel establishes a full rendering 
    /// context using the HelixToolkit. An instance of this class
    /// can act as the data source for a <see cref="Watch3DView"/>
    /// </summary>
    [Obsolete("Do not use! This will be moved to a new project in a future version of Dynamo.")]
    public class HydraWatch3DViewModel : DefaultWatch3DViewModel
    {
        private double lightAzimuthDegrees = 45.0;
        private double lightElevationDegrees = 35.0;
        private DynamoLineGeometryModel3D gridModel3D;
        private PerspectiveCamera camera;

        private readonly Size defaultPointSize = new Size(6, 6);
        private readonly Size highlightSize = new Size(8, 8);

        private static readonly float defaultDeadAlphaScale = 0.2f;
        private const float defaultLabelOffset = 0.025f;

        internal const string DefaultGridName = "Grid";
        internal const string DefaultAxesName = "Axes";
        internal const string DefaultLightName = "DirectionalLight";
        internal const string HeadLightName = "HeadLight";

        private const string PointsKey = ":points";
        private const string LinesKey = ":lines";
        private const string MeshKey = ":mesh";
        private const string TextKey = ":text";

        private const int FrameUpdateSkipCount = 200;
        private int currentFrameSkipCount;

        private const double EqualityTolerance = 0.000001;
        private double nearPlaneDistanceFactor = 0.001;
        internal const double DefaultNearClipDistance = 0.1f;
        internal const double DefaultFarClipDistance = 100000;

        //see https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-output-merger-stage-depth-bias
        private const int DepthBiasSelectedOffset = 100;
        private const int DepthBiasPoint = 0;
        private const int DepthBiasLine = 200;
        private const int DepthBiasMesh = 400;

        private Dictionary<string, string> nodesSelected = new Dictionary<string, string>();
        private readonly object element3DDictionaryMutex = new object();

#if DEBUG
        private readonly Stopwatch renderTimer = new Stopwatch();
#endif

        public event Action RequestViewRefresh;
        protected void OnRequestViewRefresh()
        {
            RequestViewRefresh?.Invoke();
        }

        protected override void OnActiveStateChanged()
        {
            if (!active && CanNavigateBackground)
            {
                CanNavigateBackground = false;
            }

            RaisePropertyChanged("IsGridVisible");
        }

        /// <summary>
        /// An event requesting to create geometries from render packages.
        /// </summary>
        public event Action<RenderPackageCache, bool> RequestCreateModels;
        private void OnRequestCreateModels(RenderPackageCache packages, bool forceAsyncCall = false)
        {
            RequestCreateModels?.Invoke(packages, forceAsyncCall);
        }

        /// <summary>
        /// An event requesting to remove geometries generated by the node.
        /// </summary>
        public event Action<NodeModel> RequestRemoveModels;
        private void OnRequestRemoveModels(NodeModel node)
        {
            if (RequestRemoveModels != null)
            {
                RequestRemoveModels(node);
            }
        }

        /// <summary>
        /// This is the initial transform applied to 
        /// elements of the scene, like the grid and world axes.
        /// </summary>
        public Transform3D SceneTransform
        {
            get
            {
                return new TranslateTransform3D(0, -0, 0);
            }
        }

        public PerspectiveCamera Camera
        {
            get
            {
                return this.camera;
            }

            set
            {
                camera = value;
                RaisePropertyChanged("Camera");
            }
        }

        public double LightAzimuthDegrees
        {
            get { return lightAzimuthDegrees; }
            set { lightAzimuthDegrees = value; }
        }

        public double LightElevationDegrees
        {
            get { return lightElevationDegrees; }
            set { lightElevationDegrees = value; }
        }

        public double NearPlaneDistanceFactor
        {
            get { return nearPlaneDistanceFactor; }
            set
            {
                nearPlaneDistanceFactor = value;
                RaisePropertyChanged("NearPlaneDistanceFactor");
            }
        }

        public override bool IsGridVisible
        {
            get => isGridVisible;
            set
            {
                if (isGridVisible == value)
                    return;

                base.IsGridVisible = value;
                // SetGridVisibility();
            }
        }

        public bool IsResizable { get; protected set; }

        /// <summary>
        /// Attempt to create a HydraWatch3DViewModel. If one cannot be created,
        /// fall back to creating a DefaultWatch3DViewModel and log the exception.
        /// </summary>
        /// <param name="model">The NodeModel to associate with the returned view model.</param>
        /// <param name="parameters">A Watch3DViewModelStartupParams object.</param>
        /// <param name="logger">A logger to be used to log the exception.</param>
        /// <returns></returns>
        public static DefaultWatch3DViewModel TryCreateHelixWatch3DViewModel(NodeModel model, Watch3DViewModelStartupParams parameters, DynamoLogger logger)
        {
            try
            {
                var vm = new HydraWatch3DViewModel(model, parameters);
                return vm;
            }
            catch (Exception ex)
            {
                logger.Log(Resources.BackgroundPreviewCreationFailureMessage, LogLevel.Console);
                logger.Log(ex.Message, LogLevel.File);

                var vm = new DefaultWatch3DViewModel(model, parameters)
                {
                    Active = false,
                    CanBeActivated = false
                };
                return vm;
            }
        }

        protected internal virtual void UpdateUpstream()
        {
        }

        // This method is about indicating whether watch3d updated its stream or not.
        protected internal virtual void OnWatchExecution()
        {
        }

        protected HydraWatch3DViewModel(NodeModel model, Watch3DViewModelStartupParams parameters)
        : base(model, parameters)
        {
            Name = Resources.BackgroundPreviewName;
            IsResizable = false;

            SetupScene();
            Initialize();
        }

        public void SerializeCamera(XmlElement camerasElement)
        {
            if (camera == null) return;

            try
            {
                var node = XmlHelper.AddNode(camerasElement, "Camera");
                XmlHelper.AddAttribute(node, "Name", Name);
                XmlHelper.AddAttribute(node, "eyeX", camera.Position.X.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "eyeY", camera.Position.Y.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "eyeZ", camera.Position.Z.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "lookX", camera.LookDirection.X.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "lookY", camera.LookDirection.Y.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "lookZ", camera.LookDirection.Z.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "upX", camera.UpDirection.X.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "upY", camera.UpDirection.Y.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "upZ", camera.UpDirection.Z.ToString(CultureInfo.InvariantCulture));
                camerasElement.AppendChild(node);

            }
            catch (Exception ex)
            {
                logger.LogError(Properties.Resources.CameraDataSaveError);
                logger.Log(ex);
            }
        }

        /// <summary>
        /// Create a CameraData object from an XmlNode representing the Camera's serialized
        /// position data.
        /// </summary>
        /// <param name="cameraNode">The XmlNode containing the camera position data.</param>
        /// <returns></returns>
        public CameraData DeserializeCamera(XmlNode cameraNode)
        {
            if (cameraNode.Attributes == null || cameraNode.Attributes.Count == 0)
            {
                return new CameraData();
            }

            try
            {
                var name = cameraNode.Attributes["Name"].Value;
                var ex = float.Parse(cameraNode.Attributes["eyeX"].Value, CultureInfo.InvariantCulture);
                var ey = float.Parse(cameraNode.Attributes["eyeY"].Value, CultureInfo.InvariantCulture);
                var ez = float.Parse(cameraNode.Attributes["eyeZ"].Value, CultureInfo.InvariantCulture);
                var lx = float.Parse(cameraNode.Attributes["lookX"].Value, CultureInfo.InvariantCulture);
                var ly = float.Parse(cameraNode.Attributes["lookY"].Value, CultureInfo.InvariantCulture);
                var lz = float.Parse(cameraNode.Attributes["lookZ"].Value, CultureInfo.InvariantCulture);
                var ux = float.Parse(cameraNode.Attributes["upX"].Value, CultureInfo.InvariantCulture);
                var uy = float.Parse(cameraNode.Attributes["upY"].Value, CultureInfo.InvariantCulture);
                var uz = float.Parse(cameraNode.Attributes["upZ"].Value, CultureInfo.InvariantCulture);

                var camData = new CameraData
                {
                    Name = name,
                    EyeX = ex,
                    EyeY = ey,
                    EyeZ = ez,
                    LookX = lx,
                    LookY = ly,
                    LookZ = lz,
                    UpX = ux,
                    UpY = uy,
                    UpZ = uz
                };

                return camData;
            }
            catch (Exception ex)
            {
                logger.LogError(Properties.Resources.CameraDataLoadError);
                logger.Log(ex);
            }

            return new CameraData();
        }

        public override void RemoveGeometryForNode(NodeModel node)
        {
            if (Active)
            {
                // Raise request for model objects to be deleted on the UI thread.
                OnRequestRemoveModels(node);
            }
        }

        public override void AddGeometryForRenderPackages(RenderPackageCache packages, bool forceAsyncCall = false)
        {
            if (Active)
            {
                // Raise request for model objects to be created on the UI thread.
                OnRequestCreateModels(packages, forceAsyncCall);
            }
        }

        protected override void OnClear()
        {
            lock (element3DDictionaryMutex)
            {
                var keysList = new List<string> { DefaultLightName, HeadLightName, DefaultGridName, DefaultAxesName };

                // TODO: Dispose geometry?

                // labelPlaces.Clear();
                nodesSelected = new Dictionary<string, string>();
            }

            OnSceneItemsChanged();
        }

        protected override void OnWorkspaceCleared(WorkspaceModel workspace)
        {
            SetCameraData(new CameraData());
            base.OnWorkspaceCleared(workspace);
        }

        protected override void OnWorkspaceOpening(object obj)
        {
            var doc = obj as XmlDocument;
            if (doc != null)
            {
                var camerasElements = doc.GetElementsByTagName("Cameras");
                if (camerasElements.Count == 0)
                {
                    return;
                }

                foreach (XmlNode cameraNode in camerasElements[0].ChildNodes)
                {
                    try
                    {
                        var camData = DeserializeCamera(cameraNode);
                        //check if the cameraData contains any NaNs
                        if (camData.containsNaN())
                        {
                            SetCameraData(new CameraData());
                        }
                        else
                        {
                            SetCameraData(camData);
                        }
                      
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex.Message);
                        logger.Log(ex);
                    }
                }

                return;
            }

            var workspaceViewInfo = obj as ExtraWorkspaceViewInfo;
            if (workspaceViewInfo != null)
            {
                var cameraJson = workspaceViewInfo.Camera.ToString();

                var settings = new JsonSerializerSettings
                {
                    Error = (sender, args) =>
                    {
                        args.ErrorContext.Handled = true;
                        Console.WriteLine(args.ErrorContext.Error);
                    },
                    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
                    TypeNameHandling = TypeNameHandling.Auto,
                    Formatting = Newtonsoft.Json.Formatting.Indented,
                    Culture = CultureInfo.InvariantCulture
                };

                var cameraData = JsonConvert.DeserializeObject<CameraData>(cameraJson, settings);

                //check if the cameraData contains any NaNs
                if (cameraData.containsNaN())
                {
                    SetCameraData(new CameraData());
                }
                else
                {
                    SetCameraData(cameraData);
                }
            }
        }

        protected override void OnWorkspaceSaving(XmlDocument doc)
        {
            var root = doc.DocumentElement;
            if (root == null)
            {
                return;
            }

            var camerasElement = doc.CreateElement("Cameras");
            SerializeCamera(camerasElement);
            root.AppendChild(camerasElement);
        }

        protected override void SelectionChangedHandler(object sender, NotifyCollectionChangedEventArgs e)
        {
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Reset:

                    // When deselecting (by clicking on the canvas), all the highlighted HelixWatch3D previews are switched off
                    // This results in a scenario whereby the list item in the WatchTree/PreviewBubble is still selected, and its
                    // labels are still displayed in the preview, but the highlighting has been switched off.
                    // In order to prevent this unintuitive UX behavior, the nodes will first be checked if they are in the 
                    // nodesSelected dictionary - if they are, they will not be switched off.

                    //var geometryModels = new List<Element3D>();
                    //foreach (var model in Element3DDictionary)
                    //{
                    //    var nodePath = model.Key.Contains(':') ? model.Key.Remove(model.Key.IndexOf(':')) : model.Key;
                    //    if (model.Value is GeometryModel3D && !nodesSelected.ContainsKey(nodePath))
                    //    {
                    //        geometryModels.Add(model.Value);
                    //    }
                    //}

                    // SetSelection(geometryModels, false);
                    break;

                case NotifyCollectionChangedAction.Remove:
                    SetSelection(e.OldItems, false);
                    break;

                case NotifyCollectionChangedAction.Add:

                    // When a node is added to the workspace, it is also added
                    // to the selection. When running automatically, this addition
                    // also triggers an execution. This would successive calls to render.
                    // To prevent this, we maintain a collection of recently added nodes, and
                    // we check if the selection is an addition and if all of the recently
                    // added nodes are contained in that selection. if so, we skip the render
                    // as this render will occur after the upcoming execution.
                    if (e.Action == NotifyCollectionChangedAction.Add && recentlyAddedNodes.Any()
                        && recentlyAddedNodes.TrueForAll(n => e.NewItems.Contains(n)))
                    {
                        recentlyAddedNodes.Clear();
                        break;
                    }

                    SetSelection(e.NewItems, true);
                    break;
            }

            if (IsolationMode)
            {
                OnIsolationModeRequestUpdate();
            }
        }

        protected override void OnNodePropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (!( sender is NodeModel node ))
            {
                return;
            }

            node.WasRenderPackageUpdatedAfterExecution = false;

            switch (e.PropertyName)
            {
                case "CachedValue":
                    Debug.WriteLine(string.Format("Requesting render packages for {0}", node.GUID));
                    node.RequestVisualUpdateAsync(scheduler, engineManager.EngineController, renderPackageFactory);
                    break;

                case "DisplayLabels":
                    node.RequestVisualUpdateAsync(scheduler, engineManager.EngineController, renderPackageFactory, true);
                    break;

                case "IsVisible":
                    var geoms = FindAllGeometryModel3DsForNode(node);
                    foreach(var g in geoms)
                    {
                        g.Value.Visibility = node.IsVisible ? Visibility.Visible : Visibility.Hidden;
                        //RaisePropertyChanged("SceneItems");
                    }

                    node.RequestVisualUpdateAsync(scheduler, engineManager.EngineController, renderPackageFactory, true);
                    break;

                case "IsFrozen":
                    var gathered = new HashSet<NodeModel>();
                    node.GetDownstreamNodes(node, gathered);
                    SetGeometryFrozen(gathered);
                    break;
            }
        }

        public override void GenerateViewGeometryFromRenderPackagesAndRequestUpdate(RenderPackageCache taskPackages)
        {
            /*foreach (var p in taskPackages)
            {
                Debug.WriteLine(string.Format("Processing render packages for {0}", p.Description));
            }
            */
            recentlyAddedNodes.Clear();

#if DEBUG
            renderTimer.Start();
#endif
            var packages = taskPackages.Packages;
            var meshPackages = packages.Cast<HelixRenderPackage>().Where(rp => rp.MeshVertexCount % 3 == 0);

            RemoveGeometryForUpdatedPackages(meshPackages);
            try
            {
                AggregateRenderPackages(meshPackages);
            }
            catch (OutOfMemoryException)
            {
                // This can happen when the amount of packages to render is too large
                string summary = Resources.RenderingMemoryOutageSummary;
                var description = Resources.RenderingMemoryOutageDescription;
                (dynamoModel as DynamoModel).Report3DPreviewOutage(summary, description);
            }
#if DEBUG
            // Defer stopping the timer until after the rendering has occurred
            Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Loaded, new Action(() =>
            {
                renderTimer.Stop();
                Debug.WriteLine(string.Format("RENDER: {0} ellapsed time rendering.", renderTimer.Elapsed));
                renderTimer.Restart();
            }));
#endif

            OnSceneItemsChanged();
        }

        private void DeleteGeometries(KeyValuePair<string, Element3D>[] geometryModels, bool requestUpdate)
        {
            lock (element3DDictionaryMutex)
            {
                if (!geometryModels.Any())
                {
                    return;
                }

                foreach (var kvp in geometryModels)
                {
                    
                    var model3D = Element3DDictionary[kvp.Key] as GeometryModel3D;
                    // check if the geometry is frozen. if the gemoetry is frozen 
                    // then do not detach from UI.
                    var frozenModel = AttachedProperties.GetIsFrozen(model3D);
                    if (frozenModel) continue;

                    Element3DDictionary.Remove(kvp.Key);
                    model3D.Dispose();

                    var nodePath = kvp.Key.Split(':')[0];
                    labelPlaces.Remove(nodePath);
                    nodesSelected.Remove(nodePath);
                }
            }

            if (!requestUpdate) return;
            OnSceneItemsChanged();
        }

        /// <summary>
        /// Delete render packages generated by the node.
        /// Note this function should be called from UI thread; otherwise call
        /// RemoveGeometryForNodeAsync().
        /// </summary>
        /// <param name="node"></param>
        /// <param name="requestUpdate"></param>
        public override void DeleteGeometryForNode(NodeModel node, bool requestUpdate = true)
        {
            var geometryModels = FindAllGeometryModel3DsForNode(node);
            DeleteGeometries(geometryModels, requestUpdate);
        }

        /// <summary>
        /// Delete render packages associated with the specified identifier.
        /// Note this function should be called from UI thread.
        /// </summary>
        /// <param name="identifier"></param>
        /// <param name="requestUpdate"></param>
        public override void DeleteGeometryForIdentifier(string identifier, bool requestUpdate = true)
        {
            var geometryModels = FindAllGeometryModel3DsForNode(identifier);
            DeleteGeometries(geometryModels, requestUpdate); 
        }

        protected override void OnModelPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "CurrentWorkspace":
                    OnClear();

                    IEnumerable<NodeModel> nodesToRender = null;

                    // Get the nodes to render from the current home workspace. For custom
                    // nodes, this will get the workspace in which the custom node is placed.
                    // This will need to be adapted when multiple home workspaces are supported,
                    // so that a specific workspace can be selected to act as the preview context.

                    var hs = dynamoModel.Workspaces.FirstOrDefault(i => i is HomeWorkspaceModel);
                    if (hs != null)
                    {
                        nodesToRender = hs.Nodes;
                    }

                    if (nodesToRender == null)
                    {
                        return;
                    }

                    foreach (var node in nodesToRender)
                    {
                        node.RequestVisualUpdateAsync(scheduler, engineManager.EngineController, renderPackageFactory, true);
                    }

                    break;
            }
        }

        /// <summary>
        /// Update the attached properties and recalculate transparency sorting
        /// after any update under Isolate Selected Geometry mode.
        /// </summary>
        protected override void OnIsolationModeRequestUpdate()
        {
            var values = Element3DDictionary.Values.ToList();

            var geometries = values.OfType<GeometryModel3D>().ToList();
            geometries.ForEach(g => AttachedProperties.SetIsolationMode(g, IsolationMode));

            if (Camera != null)
            {
                values.Sort(new Element3DComparer(Camera.Position));
            }

            if (sceneItems == null)
                sceneItems = new ObservableElement3DCollection();

            sceneItems.Clear();
            sceneItems.AddRange(values);
        }

        public override CameraData GetCameraInformation()
        {
            return camera.ToCameraData(Name);
        }

        /// <summary>
        /// Finds all output identifiers based on the context.
        /// 
        /// Ex. If there are nodes selected, returns all identifiers for outputs
        /// on the selected nodes. If you're in a custom node, returns all identifiers
        /// for the outputs from instances of those custom nodes in the graph. etc.
        /// </summary>
        /// <returns>An <see cref="IEnumerable"/> of <see cref="string"/> containing the output identifiers found in the context.</returns>
        private IEnumerable<string> FindIdentifiersForContext()
        {
            IEnumerable<string> idents = null;

            var hs = dynamoModel.Workspaces.OfType<HomeWorkspaceModel>().FirstOrDefault();
            if (hs == null)
            {
                return idents;
            }

            if (InCustomNode())
            {
                idents = FindIdentifiersForCustomNodes(hs);
            }
            else
            {
                if (DynamoSelection.Instance.Selection.Any())
                {
                    var selNodes = DynamoSelection.Instance.Selection.Where(s => s is NodeModel).Cast<NodeModel>().ToArray();
                    idents = FindIdentifiersForSelectedNodes(selNodes);
                }
                else
                {
                    idents = AllOutputIdentifiersInWorkspace(hs);
                }
            }

            return idents;
        } 

        protected override bool CanToggleCanNavigateBackground(object parameter)
        {
            return true;
        }

        internal void ComputeFrameUpdate()
        {
            // Raising a property change notification for
            // the SceneItems collections causes a full
            // re-render including sorting for transparency.
            // We don't want to do this every frame, so we
            // do this update only at a fixed interval.
            //if (currentFrameSkipCount == FrameUpdateSkipCount)
            //{
            //    RaisePropertyChanged("SceneItems");
            //    currentFrameSkipCount = 0;
            //}

            currentFrameSkipCount++;
        }

        private void OnSceneItemsChanged()
        {
            UpdateSceneItems();
            RaisePropertyChanged(nameof(SceneItems));
            OnRequestViewRefresh();
        }
   
        private KeyValuePair<string, Element3D>[] FindAllGeometryModel3DsForNode(NodeModel node)
        {
            KeyValuePair<string, Element3D>[] geometryModels;

            lock (element3DDictionaryMutex)
            {
                geometryModels = Element3DDictionary
                        .Where(x => x.Key.Contains(node.AstIdentifierGuid) && x.Value != null).ToArray();
            }

            return geometryModels;
        }

        private KeyValuePair<string, Element3D>[] FindAllGeometryModel3DsForNode(string identifier)
        {
            KeyValuePair<string, Element3D>[] geometryModels;

            lock (element3DDictionaryMutex)
            {
                geometryModels = Element3DDictionary
                        .Where(x => x.Key.Contains(identifier) && x.Value is GeometryModel3D).ToArray();
            }

            return geometryModels;
        }

        private void SetGeometryFrozen(HashSet<NodeModel> gathered)
        {
            
            foreach (var node in gathered)
            {
                var geometryModels = FindAllGeometryModel3DsForNode(node);

                if (!geometryModels.Any())
                {
                    continue;
                }

                var modelValues = geometryModels.Select(x => x.Value);

                foreach (GeometryModel3D g in modelValues)
                {
                    AttachedProperties.SetIsFrozen(g, node.IsFrozen);
                }
            }
        }

        private void SetSelection(IEnumerable<Element3D> items, bool isSelected)
        {
         
            foreach (var element in items)
            {
                AttachedProperties.SetShowSelected(element, isSelected);
            }
            SetDepthBiasBasedOnSelection(isSelected, items);
        }

        private void SetSelection(IEnumerable items, bool isSelected)
        {
            foreach (var item in items)
            {
                if (item is NodeModel node)
                {

                    var element3ds = FindAllGeometryModel3DsForNode(node);

                    if (!element3ds.Any())
                    {
                        continue;
                    }

                    var geometryModels = element3ds.Where(x => x.Value is GeometryModel3D).Select(x=>x.Value);
                    foreach (var model in geometryModels)
                    {
                        AttachedProperties.SetShowSelected(model, isSelected);
                    }

                    SetDepthBiasBasedOnSelection(isSelected, geometryModels);
                }
            }
        }

        private static void SetDepthBiasBasedOnSelection(bool isSelected, IEnumerable<Element3D> element3Ds)
        {
            foreach (var element in element3Ds)
            {
                //selected should be lowest depth
                var stdbias = 0;
                var newDepth = 0;
                switch (element)
                {
                    case DynamoGeometryModel3D t1:
                        stdbias = DepthBiasMesh;
                        break;
                    case DynamoLineGeometryModel3D t1:
                        stdbias = DepthBiasLine;
                        break;
                    case DynamoPointGeometryModel3D t1:
                        stdbias = DepthBiasPoint;
                        break;
                    // if this is an unknown type, don't modify depth bias.
                    default:
                        return;
                }
                //selected bias
                newDepth = stdbias - DepthBiasSelectedOffset;
                if (!isSelected)
                {
                    //reset depth to default for geom type.
                    newDepth = stdbias;
                }
                if (element is GeometryModel3D geom)
                {
                    geom.DepthBias = newDepth;
                }
            }
        }

        private void LogCameraWarning(string msg, Exception ex)
        {
            logger.LogWarning(msg, WarningLevel.Mild);
            logger.Log(msg);
            logger.Log(ex.Message);
        }

        private void SaveCamera(XmlElement camerasElement)
        {
            try
            {
                var node = XmlHelper.AddNode(camerasElement, "Camera");
                XmlHelper.AddAttribute(node, "Name", Name);
                XmlHelper.AddAttribute(node, "eyeX", Camera.Position.X.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "eyeY", Camera.Position.Y.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "eyeZ", Camera.Position.Z.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "lookX", Camera.LookDirection.X.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "lookY", Camera.LookDirection.Y.ToString(CultureInfo.InvariantCulture));
                XmlHelper.AddAttribute(node, "lookZ", Camera.LookDirection.Z.ToString(CultureInfo.InvariantCulture));
                camerasElement.AppendChild(node);
            }
            catch (Exception ex)
            {
                const string msg = "CAMERA: Camera position information could not be saved.";
                LogCameraWarning(msg, ex);
            }
        }

        private void LoadCamera(XmlNode cameraNode)
        {
            if (cameraNode.Attributes.Count == 0)
            {
                return;
            }

            try
            {
                Name = cameraNode.Attributes["Name"].Value;
                var ex = float.Parse(cameraNode.Attributes["eyeX"].Value);
                var ey = float.Parse(cameraNode.Attributes["eyeY"].Value);
                var ez = float.Parse(cameraNode.Attributes["eyeZ"].Value);
                var lx = float.Parse(cameraNode.Attributes["lookX"].Value);
                var ly = float.Parse(cameraNode.Attributes["lookY"].Value);
                var lz = float.Parse(cameraNode.Attributes["lookZ"].Value);

                Camera.LookDirection = new Vector3D(lx, ly, lz);
                Camera.Position = new Point3D(ex, ey, ez);
            }
            catch (Exception ex)
            {
                const string msg = "CAMERA: Camera position information could not be loaded from the file.";
                LogCameraWarning(msg, ex);
            }
        }

        private void SetupScene()
        {
            // camera setup
            Camera = new PerspectiveCamera
            {
                FieldOfView = 58.5
            };
            SetCameraData(new CameraData());

            DrawGrid();
        }

        /// <summary>
        /// Initialize the Helix with these values. These values should be attached before the 
        /// visualization starts. Deleting them and attaching them does not make any effect on helix.         
        /// So they are initialized before the process starts.
        /// </summary>
        private void Initialize()
        {
            if (Element3DDictionary == null)
            {
                throw new Exception("Hydra could not be initialized.");
            }

            // TODO: Lights

            // TODO: Grid

            // TODO: Axes

            UpdateSceneItems();
        }

        public void SetCameraData(CameraData data)
        {
            if (Camera == null) return;

            Camera.LookDirection = data.LookDirection;
            Camera.Position = data.EyePosition;
            Camera.UpDirection = data.UpDirection;
            Camera.NearPlaneDistance = data.NearPlaneDistance;
            Camera.FarPlaneDistance = data.FarPlaneDistance;
        }

        private bool InCustomNode()
        {
            return dynamoModel.CurrentWorkspace is CustomNodeWorkspaceModel;
        }

        /// <summary>
        /// Toggles on the highlighting for the specific node (in Helix preview) when
        /// selected in the PreviewBubble as well as the Watch Node
        /// </summary>
        private void ToggleTreeViewItemHighlighting(string path, bool isSelected)
        {
            // First, deselect parentnode in DynamoSelection
            var nodePath = path.Contains(':') ? path.Remove(path.IndexOf(':')) : path;
            if (DynamoSelection.Instance.Selection.Any())
            {
                var selNodes = DynamoSelection.Instance.Selection.ToList().OfType<NodeModel>();
                foreach (var node in selNodes)
                {
                    if (node.AstIdentifierBase == nodePath)
                    {
                        node.Deselect();
                    }
                }
            }

            // Next, deselect the parentnode in HelixWatch3DView
            var nodeGeometryModels = Element3DDictionary.Where(x => x.Key.Contains(nodePath) && x.Value is GeometryModel3D).ToArray();
            foreach (var nodeGeometryModel in nodeGeometryModels)
            {
                AttachedProperties.SetShowSelected(nodeGeometryModel.Value, false);
            }

            // Then, select the individual node only if isSelected is true since all geometryModels' Selected Property is set to false
            if (isSelected)
            {
                var geometryModels = Element3DDictionary.Where(x => x.Key.StartsWith(path + ":") && x.Value is GeometryModel3D).ToArray();
                foreach (var geometryModel in geometryModels)
                {
                    AttachedProperties.SetShowSelected(geometryModel.Value, isSelected);
                }
            }
        }

        internal static IEnumerable<string> FindIdentifiersForSelectedNodes(IEnumerable<NodeModel> selectedNodes)
        {
            return selectedNodes.SelectMany(n => n.OutPorts.Select(p => n.GetAstIdentifierForOutputIndex(p.Index).Value));
        }

        /// <summary>
        /// Find all output identifiers for all custom nodes in the provided workspace. 
        /// </summary>
        /// <param name="workspace">A workspace</param>
        /// <returns>An <see cref="IEnumerable"/> of <see cref="string"/> containing all output identifiers for 
        /// all custom nodes in the provided workspace, or null if the workspace is null.</returns>
        internal static IEnumerable<string> FindIdentifiersForCustomNodes(HomeWorkspaceModel workspace)
        {
            if (workspace == null)
            {
                return null;
            }

            // Remove the output identifier appended to the custom node outputs.
            var rgx = new Regex("_out[0-9]");

            var customNodes = workspace.Nodes.Where(n => n is Function);
            var idents = new List<string>();
            foreach (var n in customNodes)
            {
                if (n.IsPartiallyApplied)
                {
                    // Find output identifiers for the connected map node
                    var mapOutportsIdents =
                        n.OutPorts.SelectMany(
                            np => np.Connectors.SelectMany(
                                    c => c.End.Owner.OutPorts.Select(
                                            mp => rgx.Replace(mp.Owner.GetAstIdentifierForOutputIndex(mp.Index).Value, ""))));
                    
                    idents.AddRange(mapOutportsIdents);
                }
                else
                {
                    idents.AddRange(n.OutPorts.Select(p => rgx.Replace(n.GetAstIdentifierForOutputIndex(p.Index).Value, "")));
                }
            }
            return idents;
        }

        internal static IEnumerable<string> AllOutputIdentifiersInWorkspace(HomeWorkspaceModel workspace)
        {
            if (workspace == null)
            {
                return null;
            }

            return
                workspace.Nodes
                .Where(n => n.State != ElementState.Error)
                .SelectMany(n => n.OutPorts.Select(p => n.GetAstIdentifierForOutputIndex(p.Index).Value));
        } 

        internal static IEnumerable<GeometryModel3D> FindGeometryForIdentifiers(IEnumerable<GeometryModel3D> geometry, IEnumerable<string> identifiers)
        {
            return identifiers.SelectMany(id => geometry.Where(item => item.Name.Contains(id))).ToArray();
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                viewModel = null;

                foreach (var sceneItem in SceneItems)
                {
                    sceneItem.Dispose();
                }

                foreach (var item in Element3DDictionary.Values)
                {
                    item.Dispose();
                }
                element3DDictionary.Clear();

            }
            base.Dispose(disposing);
        }
    }
}
